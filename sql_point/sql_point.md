### 1. utf8编码设置大小写敏感

    COLLATE utf8_general_ci 表示对大小写不敏感
    
    COLLATE utf8_bin        表示对大小写敏感

### 2. 在项目中使用外键是否越多越好?
    1. 外键用于与另一张表的关联,目的是为了实现数据的强一致
    2. 如果一个功能需要正确性>性能的话,建议使用外键,可以在数据库的层面保证数据的完整性和一致性;如果不用外键,可以在业务层进行实现,不过这样
        就会使业务逻辑和数据具备一定的耦合性,业务逻辑和数据必须同时修改.最主要的是在工作中,业务层可能会经常发生变化
    3. 在大型的数据应用场景,大量的插入,更新和删除在外键的约束下会降低性能,同时数据库在进行水平拆分或垂直拆分的情况下数据库端也做不到执行
        外键约束.在高并发的场景下,外键的存在也会造成另外的开销,因为每次更新数据,都需要检查另一张表的数据,很容易造成死锁.
    4. 所以在项目初期尽量使用外键保持数据的强一致性,可靠性,并且不需要在业务层进行过多的检查.项目后期或者大业务量的项目,可以取消外键的约束
        ,在业务层来进行数据的检查保持数据一致性,提高性能,减少死锁,提高并发量

### 3. 查询语句的顺序
    select DISTINCT player_id, player_name, count(*) as num # 顺序5
    FROM player JOIN team ON player.team_id=team.team_id # 顺序1
    WHERE height > 1.80 # 顺序2
    GROUP BY player.team_id # 顺序3
    HAVING num > 2 # 顺序4
    ORDER BY num DESC # 顺序6
    LIMIT 2; # 顺序7
    
    1. form ... join ... on ...
        1. 首先通过CROSS JOIN求笛卡尔积,得到虚拟表vt1-1
        2. 通过on进行筛选,在t1基础上进行筛选得到虚拟表vt1-2
        3. 添加外部行,如果使用左连接,右连接,全连接,就会涉及到外部行,在t2的基础上增加外部行,得到虚拟表vt1-3
    2. 进行where操作根据虚拟表vt1进行筛选得到虚拟表vt2
    3. 使用group by 进行分组,得到虚拟表vt3
    4. having进行分组过滤,得到虚拟表vt4
    5. select 筛选表中提取的字段得到虚拟表vt5
    6. order by进行排序,(默认ASC递增排序,DESC递减排序),得到虚拟表vt6
    7. limit取出指定行的记录,得到虚拟表vt7
    
    特殊: 1. avg(),max()等聚集函数是在GROUP BY 之后,HAVING之前进行计算的
         2. 计算表达式是在HAVING之后SELECT之前进行计算的

### 4. count()效率问题
    1. MyISAM引擎下统计表的行数
        - 时间复杂度为O(1),因为每张MyISAM的数据表都有一个meta信息存储了row_count的值
    2. InnoDB引擎下统计表的行数
        一般情况下: COUNT(*) = COUNT(1) > COUNT(字段)
        尽量使用COUNT(*),对于COUNT(*)和COUNT(1)来说,系统会自动采用占用空间小的二级索引来进行统计
        如果有多个二级索引的时候,会使用key_len小的二级索引进行扫描,当没有二级索引的时候,才会采用主键索引进行统计
        如果需要统计某一列的非空数据行数,就只能使用COUNT(字段)
    3. 如果要统计COUNT(*),尽量在数据表上建立二级索引,这样使用COUNT(*)的时候会大大提高效率
    
### 5. ORDER BY 字段是否添加索引   (需要)
    1. MySQL中支持两种排序方式: FileSort和index排序,index排序效率更高
        1. index排序: 索引可以保证数据的有序性,因此不需要在进行排序
        2. FileSort排序: 一般在内存中进行排序,占用CPU较多,如果待排结果较大,会产生临时文件I/O到磁盘进行排序,效率较低
    2. 应该尽量使用index排序,避免使用FileSort排序

### 6. DDL(Date Definition Language)崩溃问题
    在MySQL8.0版本之前,当我们ALTER TABLE时系统崩溃了,则会遗留.frm .ibd文件,而在8.0版本之后,mysql默认的InnoDB引擎实现了原子DDL.
    原子DDL操作写入了内部隐藏的系统表,即mysql.innodb_ddl_log中,也就是说明在DDL执行过程中如果出现了失败,是可以回滚的
    说明: DDL正常运行后,ddl_log中的相应日志也会被删除,如果这中间崩溃了,重启时会根据事务是否提交了来判断是做redo,还是undo DLL操作
### 7. 常用的SQL函数
    1. 算数函数
        1. ABS(): 取绝对值
        2. MOD(): 取余,第一个参数是被除数,第二个参数是除数
        3. ROUND(): 四舍五入为指定的小数位数,两个参数,第一个参数为小数或字段名称,第二个参数是小数位数
    2. 字符串函数
        1. CONCAT(): 将多个字符串拼接起来
        2. LENGTH(): 计算字段的长度,一个汉字算3个字符,一个数字或字母算一个字符
        3. CHAR_LENGTH(): 计算字段的长度, 汉子,数字,字母都算是一个字符
        4. LOWER(): 将字符串中的字符转换为小写
        5. UPPER(): 将字符串中的字符转换为大写
        6. REPLACE(): 替换函数,3个参数. 第一个为要替换的表达式或字段名,第二个是想要查找的被替换字符串,第三个是替换成哪个字符串
        7. SUBSTRING: 截取字符串,有3个参数. 第一个是待截取的表达式或字段名,第二个是开始截取的位置,第三个是想要截取的字符串长度(注意:第三个参数是想要的长度,不是截取到第几位;mysql中字符串的索引位置是从1开始的)
    3. 日期函数
        1. CURRENT_DATE(): 系统当前日期(年月日)
        2. CURRENT_TIME(): 系统当前时间(时分秒)
        3. CURRENT_TIMESTAMP(): 系统当前时间(年月日时分秒)
        4. EXTRACT(): 抽取具体的年 月  日  时   分   秒  用法: select EXTRACT(YEAR FROM '2020-02-20 12:13:23')
        5. DATE(): 返回时间的日期部分
        6. YEAR(): 返回时间的年份部分
        7. MONTH(): 返回时间的月份部分
        8. DAY(): 返回时间的天数部分
        9. HOUR(): 返回时间的小时部分
        10: MINUTE(): 返回时间的分钟部分
        11: SECOND(): 返回时间的秒部分
    4. 转换函数
        1. CAST(): 数据类型转换,参数是一个表达式,表达式通多 AS 关键词分割了2个参数,分别是原始数据和目标数据类型
            - SELECT CASE(45.266 AS DECIMAL(5, 2)) 返回 45.27
        2. COALESCE(): 返回第一个非空数值. COALESCE(NULL, NULL, 3) 返回 3
        
### 8. 子查询的种类
    很多时候我们无法从数据表中得到查询结果,需要从 查询结果集 中再次进行查询才能得到想要的结果,这个查询结果集就叫子查询
    1. 关联子查询
        如果子查询需要查询多次,即采用循环的方式,先从外部查询开始,每次都传入子查询进行查询,然后再将结果反馈给外部,这种嵌套的执行方式就称为关联子查询
    2. 非关联子查询
        子查询从数据表中查询到了数据结果,如果这个结果只执行一次,然后这个数据结果作为主查询的条件进行执行,这样的子查询叫非关联子查询
        
### 9. EXISTS子查询
    EXISTS子查询用来判断条件是否满足,满足的话为True,不满足的话为FALSE
    例: 根据某个球员在player_score中有出场纪录判断出场过的球员并显示姓名,球员ID和球队ID
        SELECT player_id,team_id,player_name FROM player WHERE EXISTS (SELECT player_id FROM player_score WHERE player.player_id=player_score.player_id);
        
### 10. 集合比较子查询(IN ANY ALL)
    还是上面的例子使用IN
    SELECT player_id,team_id,player_name FROM player player_id IN (SELECT player_id FROM player_score WHERE player.player_id=player_score.player_id);
    使用 ANY 查找球员中大于球队1002中任意队员身高的球员,并输出球员id,姓名,身高,所属球队
    SELECT player_id,player_name,height,team_id FROM player WHERE height > ANY (SELECT height FROM player WHERE team_id=1002);
    使用 ALL 查找球员中比球队1002中所有队员身高都高的球员,并输出球员id,姓名,身高,所属球队
    SELECT player_id,player_name,height,team_id FROM player WHERE height > ALL (SELECT height FROM player WHERE team_id=1002);
    
    注意: 当使用ANY或ALL的时候,前面一定要使用比较操作符

### 11. 将子查询作为主查询的列
    查询相同的team_id在player表中所有球员的数量
    SELECT team_name, (SELECT COUNT(*) FROM player WHERE player.team_id=team.team_id) AS player_num FROM team;
    
### 12. 什么时候使用IN,什么时候使用EXISTS
    抽象两个实例语句
    1. SELECT * FROM A WHERE cc IN (SELECT cc FROM B);
    2. SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc = A.cc);
    在查询字段建立索引的前提下 表A比表B大,那么IN子查询的效率要比EXISTS子查询的效率高,如果表A比表B小,那么使用EXISTS子查询效率会高
    另: IN有一个缺陷是无法判断NULL的,如果字段里面有NULL就会出现返回,这个时候只能使用EXISTS

### 13. 常用的连接表的操作
    1. 笛卡尔积(CROSS JOIN)交叉连接
        可以把任意表进行连接,得到的数据是表的数据的乘积.
    2. 等值连接(MATURAL JOIN)
        等值连接就是进行表取笛卡尔积之后得到的数据进行过滤的操作,过滤的条件是进行等值判断
        除了使用ON ... = ... 还可以使用USING(字段)来进行等值连接,USING后面的字段必须是两个表中的同名字段
    3. 非等值连接
        非等值连接就是进行表取笛卡尔积之后得到的数据进行过滤的操作,过滤的条件是进行非等值判断     
    4. 外连接(除了查询满足条件的记录意外,还可以查询某一方不满足条件的记录)
        内连接(INNER JOIN)指的是在两张表进行连接查询时，只保留两张表中完全匹配的结果集
        左连接(LEFT JOIN)指的是在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录
        右连接(RIGHT JOIN)指的是在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录
        全连接(FULL JOIN)指的是在两张表进行连接查询时，返回左表和右表中所有匹配与没有匹配的行(MySQL不支持)
    5. 自连接
        自连接可以对多个表进行操作,也可以对同一个表进行操作
        
### 14. 视图在SQL中的作用是什么,它是怎么工作的
    1. 视图: 视图是一张虚拟表,帮我们封装了底层和数据表的接口.相当于是一张表或多张表的数据结果集
    2. 优点: 
        1. 安全,虚拟表是基于底层数据表的,我们使用视图的时候,一般是不会通过视图对底层数据进行修改,即使是使用单表的视图,也会收到限制,
           比如说计算字段,类型转换等是无法通过视图来对底层数据进行修改的,在一定程度上保证了数据表的数据安全性
        2. 简单清晰,视图是对SQL查询的封装,可以将原本复杂的SQL查询简化,在编写好查询后就可以直接重用它而不必知道基本的查询细节.
        类似于编程语言里面的函数,封装是为了更好的复用. 同时还可以在视图上再嵌套视图,这样就好比在进行模块化编程一样,结构清晰,高复用率.
    3. 语句
        1. 创建视图: CREATE VIEW 视图名 AS 查询语句
        2. 修改视图: ALTER VIEW 视图名 AS 查询语句
        3. 删除视图: DROP VIEW 视图名
    注意: 1.视图总是最新的数据,每当用户查询视图时,数据库引擎通过使用视图的SQL语句重建数据
         2. 视图是虚拟表,临时表是真实存在的数据表,但是是临时性的,用完了会删除.

### 15. 存储过程   

### 16. 事务
    1. 事务的特性(要么全部执行,要么都不执行)ACID
        1. A,原子性(Atomicity),不可分割,数据操作的最小单位
        2. C,一致性(Consistency),一致性是指数据库进行事务操作后,会由原来的一致状态,变成另一种一致的状态,
            也就是说当事务提交后,或者当一个事务在提交之前,数据库的完整性约束不能被破坏.     
        3. I,隔离性(Isolation),每个事务都是彼此隔离的,不会受到其他事务的执行影响.也就是说一个事务提交之前,对其他事务都是不可见的
        4. D,持久性(Durability),持久性通过事务日志来保证,日志包括回滚日志和重做日志,事务提交成功之后对数据的修改是持久性的,
            即使在系统出现故障的情况下,数据的修改依然是有效的.
    2. 事务的常用控制语句
        1. START TRANSACTION 或者 BEGIN: 显式的开启一个事务
        2. COMMIT: 提交事务,当提交事务后,对数据库的修改是永久性的
        3. ROLLBACK 或者 ROLLBACK TO [SAVEPOINT]: 回滚事务,撤销正在进行的所有没有提交的修改,或者将事务回滚到某个保存点
        4. SAVEPOINT: 在事务中创建保存点,方便后续针对保存点进行回滚,一个事务中可以存在多个保存点
        5. RELEASE SAVEPOINT: 删除某个保存点
        6. SET TRANSACTION: 设置事务的隔离界别
        7. set autocommit = 0;   当值为0时表示关闭自动提交,必须显示的使用COMMIT命令提交事务,MySQL的默认设置是 1, 自动提交
    3. 下面是一段SQL
        CREATE TABLE test(name varchar(255),PRIMARY KEY (name)) charset=utf8 ENGINE=InnoDB;
        SET @@completion_type = 1;
        BEGIN;
        INSERT INTO test SELECT '关羽';
        COMMIT;
        INSERT INTO test SELECT '张飞';
        INSERT INTO test SELECT '关羽';
        ROLLBACK;
        SELECT * FROM test;
    4. completion参数的作用:
        1. completion=0,这是默认情况,也就是说当我们执行COMMIT的时候会提交事务,在执行下一个事务的时候,还需要使用 START TRANSACTION 或者 BEGIN来开启
        2. completion=1,这种情况下,提交事务的时候相当于执行了COMMIT AND CHAIN,也就是开启一个链式事务,当我们提交事务之后会开启一个相同隔离级别的事务
        3. completion=2,这种情况下,COMMIT=COMMIT AND RELEASE,也就是当我们提交之后,会自动与服务器断开连接
        
### 17. 数据库索引,为什么不适用于二叉树
    1. 平衡二叉树必须满足(所有节点的左右子树高度差不超过1),执行插入还是删除操作,只要不满足上述条件,就要通过旋转来保持平衡,
        而旋转是非常耗时的,所以平衡二叉树适合用于查找多的情况
    2. 二叉树的数据结构,会导致"深度"比较深, 这种"瘦高"的特性,加大了平均查询的磁盘IO次数,随着数据量的增多,查询效率也会受到影响

### 18. B树和B+树在构造和性能上的差异
    1. B+树的中间节点并不直接存储数据
    2. B+树的查询效率更加稳定:由于非终结点并不是最终指向文件内容的结点,而只是叶子节点中关键词的索引.所以任何关键字的查找必须走一条从根节点
        到叶子节点的路.所有关键字查询的路径长度相同,导致每一个数据的查询效率相当
    3. B+树的磁盘读写代价更低: (B+树单一结点比B树存储更多的元素,IO更少)B+树的内部结点并没有指向关键字具体信息的指针,因此其内部结点相对于B树更小,
        如果把所有同一内部节点的关键字存放在同一盘块中,那么盘块所能容纳的关键字数量也就越多,一次性读入内存需要查找的关键字也就越多,相对IO读写次数就降低了.
    4. 由于B+树的数据都存储在叶子节点中,分支节点均为索引,方便扫库,只需要扫一遍叶子节点即可,但是B树因为其分支节点同样存储着数据,
        我们要找到具体的数据,需要进行一次终序遍历按顺序扫库,所以B+树更加适合在区间查询的情况(叶子节点直接串联成一条链表),所以通常B+树用于数据库索引.

### 19. 索引分类(按照物理实现方式)  
    1. 聚集索引
        按照主键来排序存储数据,所有数据存储在叶子节点上,当对数据进行插入,删除,更新等操作时,效率会比非聚集索引低
    2. 非聚集索引(二级索引或辅助索引)
        存放在单独的存储空间维护单独的索引表(只维护索引,不维护索引指向的数据),叶子节点存储的是数据的位置.非聚集索引不会影响数据表的物理存储顺序

### 20. 索引分类(按照字段个数进行划分)
    1. 单一索引
    2. 联合索引
        1. 最左匹配原则
            按照最左优先的方式进行索引的匹配,比如索引(x,y,z),使用where x=1 and y=2 and z=3就可以匹配上联合索引,如果查询条件是where y=2,
            就无法匹配上联合索引,联合索引就会失效
        2. SQL条件语句中的字段顺序并不重要,因为在逻辑查询优化阶段会自动进行 查询重写
        3. 如果我们遇到了范围条件查询,比如 < <= > >= between 等,那么范围列后的列就无法使用索引
        
### 21. innodb的三大关键特性
    1. 自适应hash索引: 当某个数据经常被访问到的时候,当满足一定条件时,就会将这个数据页的地址放到hash表中
        1. 自适应hash只保存热数据(经常被使用到的数据),并非全表数据,因此数据量并不会很大,可以让自适应hash放到缓冲池中,也就是innodb buffer pool,
            进一步提升查找效率
        2. innodb中的自适应hash相当于是"索引的索引",采用hash索引存储的是B+树中的页面的地址.
        3. 自适应Hash采用hash函数映射到一个哈希表中,所以对于字典类型的数据查找非常方便
        4. 查看是否开启自适应hash,可以通过innodb_adaptive_hash_index变量查看. show variables like "%adaptive_hash_index"
    2. 插入缓冲(insert buffer)
    3. 二次写(Double Write)

### 22. 
            
        
        
    
        
    
        

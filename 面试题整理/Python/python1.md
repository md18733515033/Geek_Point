## 目录
- [1.Python是如何进行内存管理的?](#1)
- [2.如何用Python来进行查询和替换一个文本字符串?](#2)
- [3.Python里面match()和search()的区别?](#3)
- [4.如何在一个function里面声明一个全局变量?](#4)
- [5.到底什么是Python?你可以在回答中与其他技术进行对比](#5)
- [6.“猴子补丁”（monkey patching）指的是什么？这种做法好吗？](#6)
- [7.你是如何理解Python装饰器的？](#7)
- [8.什么是闭包？如何用Python写闭包？](#8)
- [9.谈谈你对Python中多线程和多进程的理解](#9)

<a name="1"></a>        
### 1.Python是如何进行内存管理的?
答:从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制

1. 对象的引用计数机制

    - Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。
    - 引用计数增加的情况：
        1. 一个对象分配一个新名称
        2. 将其放入一个容器中（如列表、元组或字典）
    - 引用计数减少的情况：
        1. 使用del语句对对象别名显示的销毁
        2. 引用超出作用域或被重新赋值
    - sys.getrefcount( )函数可以获得对象的当前引用计数
    - 多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。
2. 垃圾回收
    1. 当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
    2. 当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。
3. 内存池机制

    Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
    1. Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
    2. Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。
    3. 对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。
 
<a name="2"></a>     
### 2.如何用Python来进行查询和替换一个文本字符串?

答：可以使用re模块中的sub()函数或者subn()函数来进行查询和替换，
```
格式：
    sub(replacement, string[,count=0])（replacement是被替换成的文本，string是需要被替换的文本，count是一个可选参数，指最大被替换的数量）
    subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量
```

<a name="3"></a>  
### 3.Python里面match()和search()的区别?
答：
```
    re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。
    re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。
```

<a name="4"></a> 
### 4.如何在一个function里面声明一个全局变量?
答：解决方法是在function的开始插入一个global声明：
```
def f()
    global x
```

<a name="5"></a> 
### 5.到底什么是Python?你可以在回答中与其他技术进行对比
答：
```
Python是一种解释型语言。这就是说，与C语言和C的衍生语言不同，Python代码在运行之前不需要编译。其他解释型语言还包括PHP和Ruby。
Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。你可以直接编写类似x=111和x="I'm a string"这样的代码，程序不会报错。
Python非常适合面向对象的编程（OOP），因为它支持通过组合（composition）与继承（inheritance）的方式定义类（class）。Python中没有访问说明符（access specifier，类似C++中的public和private），这么设计的依据是“大家都是成年人了”。
在Python语言中，函数是第一类对象（first-class objects）。这指的是它们可以被指定给变量，函数既能返回函数类型，也可以接受函数作为输入。类（class）也是第一类对象。
Python代码编写快，但是运行速度比编译语言通常要慢。好在Python允许加入基于C语言编写的扩展，因此我们能够优化代码，消除瓶颈，这点通常是可以实现的。numpy就是一个很好地例子，它的运行速度真的非常快，因为很多算术运算其实并不是通过Python实现的。
Python用途非常广泛——网络应用，自动化，科学建模，大数据应用，等等。它也常被用作“胶水语言”，帮助其他语言和组件改善运行状况。
Python让困难的事情变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。
```

<a name="6"></a> 
### 6.“猴子补丁”（monkey patching）指的是什么？这种做法好吗？
答：“猴子补丁”就是指，在函数或对象已经定义之后，再去改变它们的行为。
举个例子：
```python
import datetime
datetime.datetime.now = lambda: datetime.datetime(2012, 12, 12)
# 大部分情况下，这是种很不好的做法 - 因为函数在代码库中的行为最好是都保持一致。打“猴子补丁”的原因可能是为了测试。mock包对实现这个目的很有帮助。
```

<a name="7"></a> 
### 7.你是如何理解Python装饰器的？
答：装饰器是一个工厂函数，接受一个函数作为参数，然后返回一个新函数，其闭包中包含被装饰的函数。有了装饰器，
可以提取大量函数中与本身功能无关的类似代码 ( 这块在Flask中用于定义路由的@app.route，就是一个很好的例子)，
达到代码重用的目的。可应用于插入日志、性能测试、事务处理等方面

<a name="8"></a> 
### 8.什么是闭包？如何用Python写闭包？
闭包可以实现先将一个参数传递给一个函数，而并不立即执行，以达到延迟求值的目的。
满足以下三个条件：

    1.必须有一个内嵌函数；
    2.内嵌函数必须引用外部函数中变量；
    3.外部函数返回值必须是内嵌函数。
```python
def delay_fun(x, y):
    def caculator():
        return x+y
    return caculator

print('返回一个求和的函数，并不求和')
msum = delay_fun(3,4)
print('调用并求和:')
print(msum())
```

<a name="9"></a> 
### 9.谈谈你对Python中多线程和多进程的理解
答：进程：是资源分配的最小单位，创建和销毁开销较大；
线程：是CPU调度的最小单位，开销小，切换速度快；
操作系统将CPU时间片分配给多个线程，每个线程在指定放到时间片内完成。操作系统不断从一个线程切换到另一个线程执行，宏观上看就好像是多个线程一起执行。
Python中由于全局锁 (GIL)的存在导致，同一时间只有一个获得GIL的线程在跑，其他线程则处于等待状态，这导致了多线程只是在做分时切换，并不能利用多核。
多线程与多进程的区别：
（1）多进程中同一个变量各自有一份拷贝在每个进程中，互不影响；
（2）多线程中，所有变量都由所有线程共享，任何一个变量都可被任何一个线程修改。线程之间共享数据的最大危险在于多个线程同时更改一个变量，把内容改乱。

### 10.OSI七层模型----》网络通信的标准化模型
    1：应用层：提供用户服务，具体的内容由特定的流程规定
    2：表示层：提供数据的加密和压缩优化
    3：会话层：确定建立应用连接，选择传输服务
    4：传输层：提供数据传输服务，进行流量控制
    5：网络层：路由选择，网络互联
    6：链路层：提供链路交换，具体消息的发送
    7：物理层：物理硬件，接口，网卡的规定
    
### 11. 说说tcp和udp的区别
    1、面向连接的传输服务--》tcp协议 流式套接字
        *传输特征：可靠的数据传输
            可靠性：数据在传输中无失序、无差错、无丢失、无重复
                在数据传输前和传输结束后需要建立连接和断开连接
                    建立连接：三次握手：在面向连接的传输服务中建立连接的过程
                        1、客户端向服务器发送连接请求
                        2、服务器接收到请求进行确认，返回确认报文
                        3、客户端收到服务器回复最终确认连接
                    断开连接：四次挥手：在面向连接的传输过程中断开连接的过程
                        1、主动方发送报文，告知被动方要断开连接
                        2、被动方发回复报文，表示已经接受到请求，准备断开
                        3、被动方再次发送报文，表示准备处理就绪，可以断开
                        4、主动方发送确认报文，断开连接
        应用情况：
            适用于传输较大的内容或文件，网络良好，需要保证传输可靠性的情况
            例：聊天信息   文件的上传下载  邮件处理   网页获取
    
    2、面向无连接的传输服务---》udp协议 数据报套接字
        传输特点：
            不保证传输的可靠性
            没有连接和断开的过程
            数据的收发比较自由
        应用情况：
            网络情况可能产生丢包，对传输可靠性要求低
            例：网络视频  群聊 广播等

### 12.tcp粘包
    产生原因：
        1、tcp传输以字节流的方式发送消息，消息之间没有边界
        2、发送比接受的速度快
    受影响的情况：
        对每次发送的内容是一个独立的意思，需要单独识别
    如何处理粘包：
        1、每次发送后加一个结尾标志
        2、发送一个数据结构
        3、每次发送有一个间隔(不适合大量使用)
        
### 13.说一说tcp流式套接字和udp数据报套接字的区别
    1、流式套接字采用字节流的方式进行传输，而数据报套接字使用数据报的形式传输数据
    2、tcp套接字会产生粘包，udp不会
    3、tcp编程可以保证消息的完整性，udp不能保证
    4、tcp需要listen  accept ，udp不用
    5、tcp消息的发送接受使用recv send sendall，udp使用recvfrom，sendto     

### 14. 单点登录原理,实现
	1. 同域名下的单点登录
		一个登录系统,放在主域名下,业务访问二级域名,登陆之后将cookie的域设置为顶域,三个系统session共享,就实现了同域下的单点登录
	2. 跨域单点登录
        1. 用户访问app,用户没有登录
        2. 跳转到CAS server,即sso登录系统,sso也没有登录,弹出用户登录页
        3. 登陆成功后,sso系统进行认证,将登录状态写入sso的session,浏览器中写下sso域下的cookie
        4. sso系统登录后会生成一个ST(Service Ticket),然后跳转到app系统,同时将ST作为参数传递给app系统
        5. app系统拿到ST后,从后台向sso发送请求,验证ST是否有效
        6. 验证过后,app系统将登录状态写入session并设置app域下的cookie
        另外一个app登录
        1. 如果访问app2,app2没有登录,跳转到sso
        2. sso已经登陆了,不需要重新认证,sso生成ST,将ST作为参数传递给app2
        3. app2拿到ST,后台访问SSO, 验证ST是否有效
        4. 验证成功后,app2将登录状态写入session,并在app2域下写入cookie

### 15.web安全,csrf(跨站请求伪造)一次完整的csrf攻击是如何进行的.
	csrf简单来说就是攻击者盗用用户的身份,使用用户的身份发送恶意请求,这时请求对于服务器来说是完全合法的,从而达到攻击者的目的.比如发送邮件,发消息,盗取账号,购买商品等.
	实例:用户对银行的网站登录并发送了一个转账请求,通常该请求发送到网站后,服务器会先验证该请求是否来自一个合法的session,并且该session的用户成功登陆
	这时有一个黑客自己做了一个网站,并放上了转账请求所需要的信息,然后通过广告诱导用户访问这个网站,当用户点击进去,黑客自己的url就会带上用户自己的cookie取请求银行服务器进行转账,假如浏览器和银行之间的session并未过期,这个url就会得到响应,将钱转到了黑客账户中.
	防御手段: 
        后端:
            1. CSRF Token的方式。这种方式是在表单页面生成一个随机数，这个随机数一定要后端生成，并且对这个随机数进行存储。在前端页面中，对这个Token表单项进行隐藏,后台接收到这个请求后，判断csrf token的值是否存在，如果存在则是自己网站的请求，进行后续的流程；如果不存在，则是恶意网站的请求，直接忽略
            2. 通过请求头中的referer字段判断请求的来源。每一个发送给后端的请求，在请求头中都会包含一个referer字段，这个字段标识着请求的来源。如果请求是从银行网站发出的，这个字段会是银行网站转账页的链接,在做后端防御时，可以先取出每个请求的请求头中的referer字段，判断是不是以自己网站的域名开头，在咱们的示例中，如果referer字段是以https://www.a-bank.com/开头的，则继续执行转账操作；如果不是，则直接忽略掉这个请求
        前端:
            SameSite属性，它标识着在非同源的请求中，是否可以带上Cookie，它可以设置为3个值，分别为：Strict 是最严格的，它完全禁止在跨站情况下，发送Cookie.
            Lax:大部分跨站的请求也不会带上Cookie，但是一些导航的Get请求会带上Cookie.
            None就是关闭SameSite属性，所有的情况下都发送Cookie。不过SameSite设置None，还要同时设置Cookie的Secure属性，否则是不生效的.